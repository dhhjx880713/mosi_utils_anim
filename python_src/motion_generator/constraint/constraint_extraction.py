# -*- coding: utf-8 -*-
"""
Created on Wed Mar 04 17:15:22 2015

Implements functions used for the processing of the constraints from the input file
generated by CNL processing.

@author: erhe01
"""


import collections
import numpy as np
from utilities.io_helper_functions import load_json_file
from splines.parameterized_spline import ParameterizedSpline, plot_splines

def transform_point_from_cad_to_opengl_cs(point):
    """ Transforms a 3d point represented as a list from left handed to the 
        right handed coordinate system
    """

    transform_matrix = np.array([[1,0,0],[0,0,1],[0,-1,0]])
    return np.dot(transform_matrix,point).tolist()

def transform_unconstrained_indices_from_cad_to_opengl_cs(unconstrained_indices):
    new_indices = []
    for i in unconstrained_indices:
        if i == 0:
            new_indices.append(i)
        elif i == 1:
            new_indices.append(2)
        elif i == 2:
            new_indices.append(1)
    return new_indices
    
    
def cgkit_mat_to_numpy4x4(matrix):
    """ Converts to cgkit matrix a numpy matrix  """
    return np.array(matrix.toList(), np.float32).reshape(4,4)    

def transform_point(transformation_matrix,point):
    """ Transforms a 3d point represented as a list by a numpy transformation
    
    Parameters
    ----------
    *transformation_matrix: np.ndarray
    \tHomogenous 4x4 transformation matrix
    *point: list
    \tCartesian coordinates
    
    Returns
    -------
    * point: list
    \tThe transformed point as a list
    """
    return np.dot(transformation_matrix,np.array(point+[1,]))[:3].tolist()   



    
    
def extract_elementary_actions(mg_input):
    """ Create a mapping from action name to index in the elementary action list.
    Parameters
    ----------
    *mg_input: dict
    \t The dictionary read from the Morphable Graphs input json file.
    
    Returns
    -------
    *action_dict: OrderedDict
    \t A dictionary that maps actions to indices in the elementary action list
    """
    action_dict = collections.OrderedDict()
    index = 0
    for e in mg_input["elementaryActions"]:
        action_dict[e["action"]] = index
        index += 1
    return action_dict

    
def extract_trajectory_constraints_for_plotting(mg_input,action_index,scale_factor=1.0):
    """ Extracts 2d control points for trajectory constraints for a given action
    
    Parameters
    ----------
    *mg_input: dict
    \tElementary action list with constraints read from the json input file
    *action_index: integer
    \tIndex of an entry in the elementary action
    *scale_factor: float
    \tIs applied on cartesian coordinates
    
    Returns
    -------
    *control_points: dict of lists
    \t list of 2d control points for each joint
    """
    assert action_index < len(mg_input["elementaryActions"])
    inv_start_transformation = np.zeros(4)
    constraints_list = mg_input["elementaryActions"][action_index]["constraints"]
    control_points = {}
    for entry in constraints_list:
        joint_name = entry["joint"]
        if "trajectoryConstraints" in entry.keys():
            control_points[joint_name] = []
            control_points[joint_name].append([0,0,0])#add origin as point
            for c in entry["trajectoryConstraints"]:
                #point = [ p*scale_factor  for p in c["position"] if p!= None]
                point = [ p*scale_factor if p is not None else 0 for p in c["position"] ]
                point = transform_point(inv_start_transformation,point)
                point = [point[0],point[2]]
                control_points[joint_name].append(point)
    return control_points



def construct_trajectories_for_plotting(mg_input,scale_factor):
    """Calls extract_trajectory_constraints for each action in the input 
    and creates a spline using the ParameterizedSpline class
    """
    elementary_action_dict = extract_elementary_actions(mg_input)
    
    traj_constraints = collections.OrderedDict()
    for key in elementary_action_dict.keys():
        control_points = extract_trajectory_constraints_for_plotting(mg_input,elementary_action_dict[key],scale_factor)
        #print control_points        
        traj_constraints[key] = {}
        for joint_name in control_points.keys():
            traj_constraints[key][joint_name] = ParameterizedSpline(control_points[joint_name],2)        
    return traj_constraints

def plot_trajectory_from_mg_input_file(filename,scale_factor = 1.0):
    """ Reads the Morphable Graphs input file and plots trajectories for testing.
    
     Parameters
    ----------
    * filename: string
    \tThe path to the saved json file.
    * scalefactor: float
    \tIs applied on cartesian coordinates
    """
    
    mg_input = load_json_file(filename)
    traj_constraints = construct_trajectories_for_plotting(mg_input,scale_factor)
    plot_splines("Trajectories",traj_constraints["walk"].values())
  
def extract_root_positions(euler_frames):
    roots_2D = []
    for i in xrange(len(euler_frames)):
        position_2D = np.array([ euler_frames[i][0],euler_frames[i][1], euler_frames[i][2] ])
        #print "sample",position2D
        roots_2D.append(position_2D)
    return np.array(roots_2D) 
        
   
def extract_trajectory_constraints(constraints_list,scale_factor= 1.0):
    """ Extracts the control points for trajectory constraints for a given action.
        Components containing None are set to 0, but marked as ignored in the unconstrained_indices list.
        Note all elements in constraints_list must have the same dimensions constrained and unconstrained.
    
    Parameters
    ----------
    * constraints_list : dict
      Elementary action list with constraints read from the json input file
    * action_index : integer
      Index of an entry in the elementary action
    * scale_factor : float
      Is applied on cartesian coordinates.

    Returns
    -------
    * control_points : dict of lists
      list of control points for each joint
    * unconstrained_indices : dict of lists
      indices that should be ignored
    """
    unconstrained_indices = {}
  
    #create a control point list that can be used as input for the ParameterizedSpline class   
    control_points = {}
    for entry in constraints_list:
        joint_name = entry["joint"]
        if "trajectoryConstraints" in entry.keys():
            assert len(entry["trajectoryConstraints"])>0  and "position" in entry["trajectoryConstraints"][0].keys()
           
            #extract unconstrained dimensions
            unconstrained_indices[joint_name] = []
            idx = 0
            for v in entry["trajectoryConstraints"][0]["position"]:
                if v == None:
                    unconstrained_indices[joint_name].append(idx)
                idx += 1            
            
            control_points[joint_name] = []
            for c in entry["trajectoryConstraints"]:
                point = [ p*scale_factor if p!= None else 0 for p in c["position"] ]# else 0  where the array is None set it to 0
                control_points[joint_name].append(point)
    return control_points, unconstrained_indices



def create_constraint(joint_name,position=[None,None,None],orientation=[None,None,None],semanticAnnotation=None):
    """ Wrapper around a dict object creation
    Returns 
    -------
    * constraint : dict
      A dict containing joint, position,orientation and semanticAnnotation describing a constraint
    """
    constraint = {"joint":joint_name,"position":position,"orientation":[None,None,None],"semanticAnnotation":semanticAnnotation} # (joint, [pos_x, pos_y, pos_z],[rot_x, rot_y, rot_z])
    return constraint

    
  

    


